#include <Arduino.h>
#include <ESP32Servo.h>
#include "BluetoothSerial.h" // Biblioteca nativa do ESP32 para Bluetooth

// Objeto Bluetooth
BluetoothSerial SerialBT;

// Servos
Servo motorCima;
Servo motorMola1;
Servo motorMola2;
Servo motorMola3;
Servo motorBaixo;

// Pinos dos servos
#define MOTOR_CIMA_PIN   27
#define MOTOR_MOLA1_PIN  13
#define MOTOR_MOLA2_PIN  12
#define MOTOR_MOLA3_PIN  14
#define MOTOR_BAIXO_PIN  26

// Estados possiveis
typedef enum {
  ESTADO_RELAXADO,
  PRESO_DISTENDIDO,
  SOBE_1,
  DESCE_1,
  PRESO_CONTRAIDO,
  SOBE_2,
  DESCE_2
} Estado;

// Estado atual
Estado estado = PRESO_DISTENDIDO;

// Variavel para saber se o ultimo movimento foi subida (true) ou descida (false)
// Substitui os antigos bools de ciclo para controlar a inversao
bool ultimoSentidoFoiSubida = true; 

const char* nomeEstado(Estado e) {
  switch (e) {
    case ESTADO_RELAXADO: return "RELAXADO";
    case PRESO_DISTENDIDO: return "PRESO_DISTENDIDO";
    case SOBE_1: return "SOBE_1";
    case DESCE_1: return "DESCE_1";
    case PRESO_CONTRAIDO: return "PRESO_CONTRAIDO";
    case SOBE_2: return "SOBE_2";
    case DESCE_2: return "DESCE_2";
    default: return "DESCONHECIDO";
  }
}

void setServoPosicao(Servo &servo, bool ativo) {
  if (ativo) servo.write(90);
  else servo.write(0);
}

// Move as 3 molas simultaneamente
void setServoContinuo(int v1, int v2, int v3, unsigned long duracao) {
  motorMola1.write(v1);
  motorMola2.write(v2);
  motorMola3.write(v3);
  
  // O robo fica bloqueado aqui enquanto se move (o que eh bom para sincronia)
  delay(duracao); 
  
  motorMola1.write(90); 
  motorMola2.write(90);
  motorMola3.write(90);
}

void aplicaEstado(Estado e) {
  // Envia status para Debug (USB) e App (Bluetooth)
  String msg = "Estado: " + String(nomeEstado(e));
  Serial.println(msg);
  SerialBT.println(msg);

  switch (e) {
    case ESTADO_RELAXADO:
      setServoPosicao(motorCima, false);
      setServoPosicao(motorBaixo, false);
      setServoContinuo(90, 90, 90, 0);
      break;

    case PRESO_DISTENDIDO:
      setServoPosicao(motorCima, true);
      setServoPosicao(motorBaixo, true);
      setServoContinuo(90, 90, 90, 100); 
      break;

    case SOBE_1:
      setServoPosicao(motorCima, true);
      setServoPosicao(motorBaixo, false);
      setServoContinuo(0, 0, 0, 2000); 
      break;

    case DESCE_1:
      setServoPosicao(motorCima, false);
      setServoPosicao(motorBaixo, true);
      setServoContinuo(0, 0, 0, 2000); 
      break;

    case PRESO_CONTRAIDO:
      setServoPosicao(motorCima, true);
      setServoPosicao(motorBaixo, true);
      setServoContinuo(90, 90, 90, 100);
      break;

    case SOBE_2:
      setServoPosicao(motorCima, false);
      setServoPosicao(motorBaixo, true);
      setServoContinuo(180, 180, 180, 2000);
      break;

    case DESCE_2:
      setServoPosicao(motorCima, true);
      setServoPosicao(motorBaixo, false);
      setServoContinuo(180, 180, 180, 2000);
      break;
  }
}

// Logica para encontrar o estado seguro mais proximo (pausa)
Estado pausaEstado(Estado e) {
  if (e == SOBE_1 || e == DESCE_1) return PRESO_CONTRAIDO;
  else if (e == SOBE_2 || e == DESCE_2) return PRESO_DISTENDIDO;
  else return e;
}

// Verifica se precisa inverter a direcao baseada no comando atual vs ultimo sentido
void verificarInversao(bool indoParaCima) {
  if (indoParaCima && !ultimoSentidoFoiSubida) {
    // Quero subir, mas estava descendo
    if (estado == DESCE_1) estado = PRESO_CONTRAIDO;
    else if (estado == DESCE_2) estado = PRESO_DISTENDIDO;
    aplicaEstado(estado);
  }
  else if (!indoParaCima && ultimoSentidoFoiSubida) {
    // Quero descer, mas estava subindo
    if (estado == SOBE_1) estado = PRESO_CONTRAIDO;
    else if (estado == SOBE_2) estado = PRESO_DISTENDIDO;
    aplicaEstado(estado);
  }
  ultimoSentidoFoiSubida = indoParaCima;
}

void setup() {
  Serial.begin(115200);
  
  // Inicia o Bluetooth
  SerialBT.begin("Robo_Molas"); 
  Serial.println("Bluetooth iniciado! Conecte-se e segure o botao para mover.");

  motorCima.attach(MOTOR_CIMA_PIN);
  motorMola1.attach(MOTOR_MOLA1_PIN);
  motorMola2.attach(MOTOR_MOLA2_PIN);
  motorMola3.attach(MOTOR_MOLA3_PIN);
  motorBaixo.attach(MOTOR_BAIXO_PIN);

  aplicaEstado(estado);
}

void loop() {
  char comando = 0;

  // 1. Limpa o buffer do Bluetooth e pega o ULTIMO caractere recebido.
  // Isso eh crucial: se o app mandar 50 letras 'F' enquanto voce segura,
  // e voce soltar, queremos garantir que o robo pare logo, e nao
  // fique processando as 50 letras antigas.
  if (SerialBT.available()) {
    while (SerialBT.available()) {
      comando = SerialBT.read();
    }
  }

  // 2. Logica de Controle (Hold to Move)
  
  // --- SUBIR (Enquanto segura botao 's' ou 'F') ---
  if (comando == 's' || comando == 'F') {
    verificarInversao(true); 
    
    // Calcula o proximo passo da subida
    if (estado == PRESO_DISTENDIDO) estado = SOBE_1;
    else if (estado == SOBE_1) estado = PRESO_CONTRAIDO;
    else if (estado == PRESO_CONTRAIDO) estado = SOBE_2;
    else if (estado == SOBE_2) estado = PRESO_DISTENDIDO;
    
    // Executa. O robo ficara ocupado por 2s ou 0.1s aqui.
    aplicaEstado(estado); 
  }
  
  // --- DESCER (Enquanto segura botao 'd' ou 'B') ---
  else if (comando == 'd' || comando == 'B') {
    verificarInversao(false); 
    
    // Calcula o proximo passo da descida
    if (estado == PRESO_DISTENDIDO) estado = DESCE_1;
    else if (estado == DESCE_1) estado = PRESO_CONTRAIDO;
    else if (estado == PRESO_CONTRAIDO) estado = DESCE_2;
    else if (estado == DESCE_2) estado = PRESO_DISTENDIDO;
    
    aplicaEstado(estado);
  }
  
  // --- ABORTAR (Botao 'a') ---
  else if (comando == 'a') {
    estado = pausaEstado(estado);
    aplicaEstado(estado);
    delay(2000);
    if (estado == PRESO_CONTRAIDO) {
        setServoContinuo(180, 180, 180, 2000);
    } 
    estado = ESTADO_RELAXADO;
    aplicaEstado(estado);
  }
  
  // --- SOLTOU O BOTAO (Nenhum comando recebido) ---
  else {
    // Se nao tem comando, forca a pausa (trava os motores)
    Estado estadoPausa = pausaEstado(estado);
    
    // So aplica se mudou alguma coisa, pra nao ficar mandando comando repetido a toa
    if (estado != estadoPausa) {
      estado = estadoPausa;
      aplicaEstado(estado);
    }
    
    // Pequeno delay pra economizar processamento enquanto espera
    delay(50);
  }
}
